# CHIP8 Virtual Machine Steps:
# Input - store key input states and check these per cycle.
# Output - 64x32 display(array of pixels are either in the on or off state(0 || 1)) & sound buzzer. 
# CPU - CowGods CHIP8 Technical reference http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#0.0
# Memory - can hold up to 4096 bytes which includes: the interpreter, fonts, and inputted ROM.
#----------------------------------------------------------------------------------------------
# We will be storing register values as 16 zeros. Also, we will have two time registers 
# defined by two variables that we decrement per cycle. We will also be dealing with a 
# stack of 16 elements that we'll just need to make into a list.
#----------------------------------------------------------------------------------------------
# We're going to be subclassing pyglet (that'll handle graphics, sound output, and keyboard handling)
# and Overriding whatever def we need from there.
# Added numpy to several functions

import sys
import random
import pyglet
from pyglet.window import key
from pyglet.media import synthesis
import numpy as np

#map binding keys
keymap = {
    key._1: 0x1, key._2: 0x2, key._3: 0x3, key._4: 0xC,
    key.Q: 0x4, key.W: 0x5, key.E: 0x6, key.R: 0xD,
    key.A: 0x7, key.S: 0x8, key.D: 0x9, key.F: 0xE,
    key.Z: 0xA, key.X: 0x0, key.C: 0xB, key.V: 0xF,
}

# set fonts (binary pixel patterns)
fontset = [
    0xF0, 0x90, 0x90, 0x90, 0xF0,  # 0
    0x20, 0x60, 0x20, 0x20, 0x70,  # 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0,  # 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0,  # 3
    0x90, 0x90, 0xF0, 0x10, 0x10,  # 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0,  # 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0,  # 6
    0xF0, 0x10, 0x20, 0x40, 0x40,  # 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0,  # 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0,  # 9
    0xF0, 0x90, 0xF0, 0x90, 0x90,  # A
    0xE0, 0x90, 0xE0, 0x90, 0xE0,  # B
    0xF0, 0x80, 0x80, 0x80, 0xF0,  # C
    0xE0, 0x90, 0x90, 0x90, 0xE0,  # D
    0xF0, 0x80, 0xF0, 0x80, 0xF0,  # E
    0xF0, 0x80, 0xF0, 0x80, 0x80   # F
] #notice 80 bytes

# ---- Configuration ----
scale = 10
width, height = 64, 32
window_width, window_height = width * scale, height * scale
CPU_HZ = 600
timer_HZ = 60

def generate_beep(duration=0.1, frequency=440, sample_rate=44100):
    wave = synthesis.Sine(duration=duration, frequency=frequency, sample_rate=sample_rate)
    return pyglet.media.StaticSource(wave)


class Chip8(pyglet.window.Window):

    def __init__(self, romname):
        super().__init__(
            width=window_width,
            height=window_height,
            caption="CHIP-8 Emulator",
            vsync=False
        )

        #
        #replaced Python lists with NumPy arrays for memory, vram and registers
        self.memory = np.zeros(4096, dtype=np.uint8)
        self.vram = np.zeros(width * height, dtype=np.uint8)
        self.V = np.zeros(16, dtype=np.uint8)
        self.I = np.uint16(0)
        self.pc = np.uint16(0x200)

        self.stack = np.zeros(16, dtype=np.uint16)
        self.sp = 0

        self.keys = np.zeros(16, dtype=np.uint8)
        self.delay = 0
        self.sound = 0
        self.should_draw = True
        self.push_handlers(self)

        # Performance tracking
        self.cycle_count = 0
        self.cycles_per_second = 0
        self.fps = 0.0
        self.fps_label = pyglet.text.Label(
            "FPS: 0.000",
            font_size=12,
            x=5,
            y=window_height - 15,
            anchor_x='left',
            anchor_y='center',
            color=(255, 255, 255, 255)
        )

        # Pixel image
        self.pixel = pyglet.image.SolidColorImagePattern((255, 255, 255, 255)).create_image(scale, scale)

        # Load fontset into memory
        self.memory[:len(fontset)] = np.fromiter(fontset, dtype=np.uint8)

        # Load ROM
        print("Loading ROM:", romname)
        with open(romname, "rb") as f:
            rom = f.read()
        rom_arr = np.frombuffer(rom, dtype=np.uint8)
        self.memory[0x200:0x200 + rom_arr.size] = rom_arr

        # Beep sound
        self.sound_playing = False

        # Pre-allocated small framebuffer (64x32 RGBA). We'll upscale on CPU using numpy.repeat
        self._small_framebuf = np.zeros((height, width, 4), dtype=np.uint8)
        self._small_framebuf[..., 3] = 255

        # Schedule the loops
        pyglet.clock.schedule_interval(self.tick, 1 / CPU_HZ)       # CPU cycles
        pyglet.clock.schedule(self.draw_frame)   # Screen redraw (at 60Hz)
        pyglet.clock.schedule_interval(self._timer_tick, 1 / timer_HZ)

        # Performance tracking counters
        self._fps_counter = 0          # counts frames drawn in current second
        self._cps_counter = 0          # counts CPU cycles in current second
        self._bench_time = pyglet.clock.get_default().time()  # start time reference

        # Labels for HUD
        self.fps_label = pyglet.text.Label(
            "FPS: 0",
            font_size=12,
            x=5,
            y=window_height - 15,
            anchor_x='left',
            anchor_y='center',
            color=(255, 255, 255, 255)
        )
        self.cps_label = pyglet.text.Label(
            "Cycles/s: 0",
            font_size=12,
            x=5,
            y=window_height - 30,
            anchor_x='left',
            anchor_y='center',
            color=(255, 255, 255, 255)
        )
        pyglet.clock.schedule_interval(self._update_bench, 1.0)  # update FPS/CPS every second

    # ---- FPS / CPS ----
    def _update_bench(self, dt):
        """
        Update FPS and CPS once per second.
        """
        now = pyglet.clock.get_default().time()
        elapsed = now - self._bench_time
        if elapsed >= 1.0:
            # Update FPS and CPS labels
            self.fps_label.text = f"FPS: {self._fps_counter / elapsed:.1f}"
            self.cps_label.text = f"Cycles/s: {self._cps_counter}"

            # Reset counters for next second
            self._fps_counter = 0
            self._cps_counter = 0
            self._bench_time = now

    # ---- Draw loop ----
    def draw_frame(self, dt):
        if self.should_draw:
            self.dispatch_event('on_draw')

    # ---- CPU (runs at CPU_HZ) ----
    def tick(self, dt):
        self._cps_counter += 1

        # Fetch opcode
        opcode = (int(self.memory[self.pc]) << 8) | int(self.memory[self.pc + 1])
        self.pc = np.uint16(self.pc + 2)

        nnn = opcode & 0x0FFF
        n = opcode & 0x000F
        x = (opcode >> 8) & 0xF
        y = (opcode >> 4) & 0xF
        kk = opcode & 0xFF

        # ---- Opcode implementations (same logic, now using NumPy storage) ----
        if opcode == 0x00E0:           # CLS
            self.vram.fill(0)
            self.should_draw = True

        elif opcode == 0x00EE:         # RET
            if self.sp == 0:
                self.pc = np.uint16(0x200)
            else:
                self.sp -= 1
                self.pc = self.stack[self.sp]

        elif opcode & 0xF000 == 0x1000:  # JP
            self.pc = np.uint16(nnn)

        elif opcode & 0xF000 == 0x2000:  # CALL
            if self.sp < 16:
                self.stack[self.sp] = self.pc
                self.sp += 1
            self.pc = np.uint16(nnn)

        elif opcode & 0xF000 == 0x3000:  # SE Vx, byte
            if self.V[x] == kk: self.pc = np.uint16(self.pc + 2)
        elif opcode & 0xF000 == 0x4000:  # SNE Vx, byte
            if self.V[x] != kk: self.pc = np.uint16(self.pc + 2)
        elif opcode & 0xF00F == 0x5000:  # SE Vx, Vy
            if self.V[x] == self.V[y]: self.pc = np.uint16(self.pc + 2)
        elif opcode & 0xF000 == 0x6000:  # LD Vx, byte
            self.V[x] = kk
        elif opcode & 0xF000 == 0x7000:  # ADD Vx, byte
            self.V[x] = (int(self.V[x]) + kk) & 0xFF
        elif opcode & 0xF00F == 0x8000:  # LD Vx, Vy
            self.V[x] = self.V[y]
        elif opcode & 0xF00F == 0x8001:  # OR
            self.V[x] |= self.V[y]
        elif opcode & 0xF00F == 0x8002:  # AND
            self.V[x] &= self.V[y]
        elif opcode & 0xF00F == 0x8003:  # XOR
            self.V[x] ^= self.V[y]
        elif opcode & 0xF00F == 0x8004:  # ADD + carry
            total = int(self.V[x]) + int(self.V[y])
            self.V[0xF] = 1 if total > 0xFF else 0
            self.V[x] = total & 0xFF
        elif opcode & 0xF00F == 0x8005:  # SUB
            self.V[0xF] = 1 if self.V[x] > self.V[y] else 0
            self.V[x] = (int(self.V[x]) - int(self.V[y])) & 0xFF
        elif opcode & 0xF00F == 0x8006:  # SHR
            self.V[0xF] = int(self.V[x] & 1)
            self.V[x] = (int(self.V[x]) >> 1) & 0xFF
        elif opcode & 0xF00F == 0x8007:  # SUBN
            self.V[0xF] = 1 if self.V[y] > self.V[x] else 0
            self.V[x] = (int(self.V[y]) - int(self.V[x])) & 0xFF
        elif opcode & 0xF00F == 0x800E:  # SHL
            self.V[0xF] = (int(self.V[x]) >> 7) & 1
            self.V[x] = (int(self.V[x]) << 1) & 0xFF
        elif opcode & 0xF00F == 0x9000:  # SNE Vx, Vy
            if self.V[x] != self.V[y]: self.pc = np.uint16(self.pc + 2)
        elif opcode & 0xF000 == 0xA000:  # LD I, addr
            self.I = np.uint16(nnn)

        elif opcode & 0xF000 == 0xD000:  # DRW Vx, Vy, n
            # Draw sprite at (Vx, Vy) with n rows from memory[I..]
            px = int(self.V[x])
            py = int(self.V[y])
            self.V[0xF] = 0

            for row in range(n):
                sprite = int(self.memory[int(self.I) + row])
                if sprite == 0:
                    continue
                for bit in range(8):
                    if sprite & (0x80 >> bit):
                        vx = (px + bit) % width
                        vy = (py + row) % height
                        index = vx + vy * width
                        if self.vram[index] == 1:
                            self.V[0xF] = 1
                        self.vram[index] ^= 1
            self.should_draw = True

        elif opcode & 0xF0FF == 0xE09E:  # SKP
            if self.keys[int(self.V[x])]: self.pc = np.uint16(self.pc + 2)
        elif opcode & 0xF0FF == 0xE0A1:  # SKNP
            if not self.keys[int(self.V[x])]: self.pc = np.uint16(self.pc + 2)
        elif opcode & 0xF0FF == 0xF007:  # LD Vx, DT
            self.V[x] = np.uint8(self.delay)
        elif opcode & 0xF0FF == 0xF00A:  # WAIT KEY
            for i in range(16):
                if self.keys[i]:
                    self.V[x] = np.uint8(i)
                    break
            else:
                # no key pressed -> repeat instruction by backing PC up
                self.pc = np.uint16(self.pc - 2)
        elif opcode & 0xF0FF == 0xF015:  # LD DT, Vx
            self.delay = int(self.V[x])
        elif opcode & 0xF0FF == 0xF018:  # LD ST, Vx (sound)
            self.sound = int(self.V[x])
        elif opcode & 0xF0FF == 0xF01E:  # ADD I, Vx
            self.I = np.uint16((int(self.I) + int(self.V[x])) & 0xFFF)
        elif opcode & 0xF0FF == 0xF029:  # FONT
            self.I = np.uint16(int(self.V[x]) * 5)
        elif opcode & 0xF0FF == 0xF033:  # BCD
            v = int(self.V[x])
            self.memory[int(self.I)] = np.uint8(v // 100)
            self.memory[int(self.I) + 1] = np.uint8((v // 10) % 10)
            self.memory[int(self.I) + 2] = np.uint8(v % 10)
        elif opcode & 0xF0FF == 0xF055:  # STORE
            self.memory[int(self.I):int(self.I) + x + 1] = self.V[:x + 1]
        elif opcode & 0xF0FF == 0xF065:  # LOAD
            self.V[:x + 1] = self.memory[int(self.I):int(self.I) + x + 1]

    def _play_beep(self, duration=0.2, frequency=440, pitch_variation=30):
        freq = frequency + random.randint(-pitch_variation, pitch_variation)
        wave = synthesis.Sine(duration=duration, frequency=freq, sample_rate=44100)
        player = pyglet.media.Player()
        player.queue(wave)
        player.play()
        self.sound_playing = True
        def on_eos():
            self.sound_playing = False
            player.delete()
        player.on_eos = on_eos

    def on_draw(self):
        if not self.should_draw:
            return
        self.clear()
        vram_2d = self.vram.reshape((height, width))
        vram_flipped = np.flipud(vram_2d)  # top of vram is top of screen

        # Fill small RGBA buffer (white for 1, black for 0)
        self._small_framebuf[..., :3] = (vram_flipped[:, :, None] * 255).astype(np.uint8)
        # alpha channel already set to 255 in init

        # Upscale CPU-side using numpy.repeat so the final blit is 1:1
        if scale != 1:
            scaled = np.repeat(np.repeat(self._small_framebuf, scale, axis=0), scale, axis=1)
        else:
            scaled = self._small_framebuf

        # Create ImageData at window resolution
        image = pyglet.image.ImageData(window_width, window_height, 'RGBA', scaled.tobytes())
        image.blit(0, 0)

        # Draw FPS and CPS
        self.fps_label.draw()
        self.cps_label.draw()

        self.should_draw = False

        # Increment FPS counter
        self._fps_counter += 1

    # Keyboard
    def on_key_press(self, symbol, modifiers):
        if symbol in keymap:
            self.keys[keymap[symbol]] = 1

    def on_key_release(self, symbol, modifiers):
        if symbol in keymap:
            self.keys[keymap[symbol]] = 0

    def _timer_tick(self, dt):
        if self.delay > 0: self.delay -= 1
        if self.sound > 0:
            self.sound -= 1
            if not self.sound_playing:
                self._play_beep()
        else:
            self.sound_playing = False

#Main
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python chip8_emulator.py romfile")
        sys.exit(1)

    window = Chip8(sys.argv[1])
    pyglet.app.run()
